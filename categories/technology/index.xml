<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>technology on Seng Mitnick</title>
    <link>https://sengmitnick.com/categories/technology/</link>
    <description>Recent content in technology on Seng Mitnick</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 17 Oct 2021 16:21:36 +0800</lastBuildDate><atom:link href="https://sengmitnick.com/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于disqus-php-api在Hexo博客中使用Disqus</title>
      <link>https://sengmitnick.com/blog/104/</link>
      <pubDate>Sun, 16 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://sengmitnick.com/blog/104/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;废话少说，这里基于 &lt;a href=&#34;https://fooleap.org&#34;&gt;fooleap&lt;/a&gt; 的 &lt;a href=&#34;https://github.com/fooleap/disqus-php-api&#34;&gt;disqus-php-api&lt;/a&gt; 对Hexo中的NexT主题进行兼容。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Vant Openharmony 开发经验分享</title>
      <link>https://sengmitnick.com/blog/352/</link>
      <pubDate>Sun, 17 Oct 2021 16:21:36 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/352/</guid>
      <description>前言 一个朋友给我推了链接，就是OpenHarmony组件开发大赛啦。然后按照官网的参赛流程，加入了大赛的微信群。
过程 开发环境配置 按照官网提供的 OpenHarmony JS项目开发流程 逐步配置。在一个天清气朗的周末，把 open-harmony-js-demos 仓储运行起来啦。
PS: 还好途中没遇到奇奇怪怪的问题，哈哈:)
参赛选型 我看 Openharmony 组件 定位于手机和手表这一块，而在手机端的组件库全面性和活跃度，无疑是 Vant 了，而且最近给公司开发手机端的React&amp;amp;Taro组件库也是参考了 Vant 的源码的，熟悉程度也算可以了。
搭建仓储 开发一个组件库的流程，我们完全可以站在巨人的肩膀上，在这个搭建过程中，我参考了以下仓储的源码与其中思路：
 Vant Vant Weapp Ant Design  创建组织和仓储 一个开源组件库的仓储创建，一定不能在个人的名下，这对于后续社区的参与人员与维护都是极其不便利的，所以无论是国外的github还是国内的gitee都提供了创建组织的选项。
因为是gitee组织的比赛，所以选择了在gitee下创建了Vant Openharmony组织，然后在该组织下创建相应的仓储。
我这里创建了两个仓储，一个是组建库的源仓储，另一个是基于 open-harmony-js-demos 的 example ，主要用来测试和演示组件库的～
组织文件结构 既然做的是 Vant 的 Openharmony 版本，那么在 官方使用文档 这一块还是保持一致的好，通过阅读 Vant 的源码发现官方有一个 Vue 组件库构建工具 Vant Cli。所以在项目初始化可以通过 Vant Cli 构建我们的项目。
但是呢，Vant Cli 是 针对 Vue 组件库的构建工具，很明显它自带的文件结构并不符合 Openharmony 组件库的，需要我们对其进行进一步的改造。
我们把 Openharmony 自定义组件所需要的文件放到 packages 文件夹下，得到以下的文件结构。
但是呢，我自己更喜欢 typescript 和 less ，所以对其捣鼓一番就得到以下的文件结构。</description>
    </item>
    
    <item>
      <title>YARN--选择性依赖解决方案</title>
      <link>https://sengmitnick.com/blog/351/</link>
      <pubDate>Sat, 16 Oct 2021 17:25:05 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/351/</guid>
      <description>前言 才过了一晚，代码没怎么改过，用 jenkins 打包就报错了，截图如下：
思考 其实看截图意思还是很明了的，明显是某个依赖包最近更新版本了，然后新版本有Bug。
直接去npm看看，果不其然。
解决 但是这个依赖包并不在当前项目 dependencies 里面，很显然是某个子包下的 dependencies 了 (其实熟悉 Antd 的童鞋就知道这个包是在 antd =&amp;gt; rc-field-form =&amp;gt; async-validator)。这种情况我们也不可能去社区让人家改 async-validator 的版本呀！
那么怎么解决呢？
如果你使用 yarn 进行 install ，那么你这个时候就可以用 resolutions 了。
最终通过在 package.json 添加如下配置即可解决啦。
参考  Selective dependency resolutions  </description>
    </item>
    
    <item>
      <title>LazyMan的现代化实现</title>
      <link>https://sengmitnick.com/blog/350/</link>
      <pubDate>Mon, 11 Oct 2021 15:51:53 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/350/</guid>
      <description>实现一个LazyMan，可以按照以下方式调用: LazyMan(&amp;quot;Hank&amp;quot;)输出: Hi! This is Hank! LazyMan(&amp;quot;Hank&amp;quot;).sleep(10).eat(&amp;quot;dinner&amp;quot;)输出 Hi! This is Hank! //等待10秒.. Wake up after 10 Eat dinner~ LazyMan(&amp;quot;Hank&amp;quot;).eat(&amp;quot;dinner&amp;quot;).eat(&amp;quot;supper&amp;quot;)输出 Hi This is Hank! Eat dinner~ Eat supper~ LazyMan(&amp;quot;Hank&amp;quot;).sleepFirst(5).eat(&amp;quot;supper&amp;quot;)输出 //等待5秒 Wake up after 5 Hi This is Hank! Eat supper 以此类推。 class LazyManC { constructor(name) { this.name = name; this.tasks = [this.log.bind(this)]; setTimeout(async () =&amp;gt; { for (const fn of this.tasks) { await fn(); } }, 0); } log() { console.log(`Hi! This is ${this.</description>
    </item>
    
    <item>
      <title>记录一次样式多次被引入的问题解决过程</title>
      <link>https://sengmitnick.com/blog/336/</link>
      <pubDate>Tue, 24 Aug 2021 18:50:04 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/336/</guid>
      <description>新写的组件库有全局样式，引起了一次样式多次被引入的问题。遂，进行了一次详细的分析与解决过程。
 通过问题分析，发现导致样式多次被引入的问题有以下：
 自建组件库全局样式多次被引入； 第三方组件库（Antd）不合理的引入方式引起重复样式覆盖； 打包工具（umi）的按需引入所引起的样式重复引入。  自建组件库全局样式多次被引入 通过删除原有默认引入的模式，改为手动引入。
https://gitee.com/pxx-design/pxx-design/commit/2cbf741560cab34ac4724af2fecb1934c659378a
💡 Tips: 后续可以研究antd的全局样式解决方案。
第三方组件库不合理的引入方式 通过代码审查，发现组件库和项目中引入antd的样式路径有 antd/es/*、antd/lib/*。导致antd的样式会加载两次。
项目使用 umi 作为打包工具，其中，通过翻阅 plugin-antd 的源码，发现编译后以antd/es/*为基准。于是修改组件库的 babel-plugin-import 的配置和项目中的引入方式。
 plugin-antd
   💡 Tips: 目前只是在文档里规范了开发人员的规则，后续研究通过编译或eslint的方式强行提示。
打包工具的按需引入所引起的样式重复引入 该问题待解决，还没学到解决办法～
END……</description>
    </item>
    
    <item>
      <title>TypeScript 使用宝典</title>
      <link>https://sengmitnick.com/blog/333/</link>
      <pubDate>Fri, 06 Aug 2021 10:27:06 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/333/</guid>
      <description>jsDoc 详细资料：https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html
 is &amp;amp; typeof https://www.typescriptlang.org/docs/handbook/advanced-types.html#typeof-type-guards https://www.typescriptlang.org/docs/handbook/advanced-types.html#instanceof-type-guards
非空断言 https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator
// Compiled with --strictNullChecks function validateEntity(e?: Entity) { // Throw exception if e is null or invalid entity } function processEntity(e?: Entity) { validateEntity(e); let s = e!.name; // Assert that e is non-null and access name } const 断言 https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions
应用场景：自定义 hook 可以用得比较多， React.useState 就是如此
const useFlag = (initialValue = false) =&amp;gt; { const [flag, setFlag] = React.useState(initialValue); const up = React.</description>
    </item>
    
    <item>
      <title>umi.theme 参数剖析</title>
      <link>https://sengmitnick.com/blog/332/</link>
      <pubDate>Thu, 08 Jul 2021 10:24:07 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/332/</guid>
      <description>其实就是 less的modifyVars功能
如果是通过js引入，会转化成less的格式：
输入：
module.exports = { &amp;#39;@hd&amp;#39;: &amp;#39;1px&amp;#39;, &amp;#39;@primary-color&amp;#39;: &amp;#39;#1E78FF&amp;#39;, &amp;#39;@url&amp;#39;: `&amp;#39;https://ant-design.gitee.io/components/upload-cn/&amp;#39;`, }; 输出：
@hd: 1px; @primary-color: #1E78FF; @url: &#39;https://ant-design.gitee.io/components/upload-cn/&#39;; PS: 注意声明链接时必须有引号，不然会报错哦～
基于modifyVars功能可以实现类似的CSS In JS 功能哦～</description>
    </item>
    
    <item>
      <title>Prettier 使用宝典</title>
      <link>https://sengmitnick.com/blog/330/</link>
      <pubDate>Tue, 25 May 2021 13:47:05 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/330/</guid>
      <description>VSCODE 安装 Prettier 的官方扩展：https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode
配置 resolveGlobalModules ，使 Prettier 使用项目本地依赖项中 Prettier。
{ &amp;#34;prettier.resolveGlobalModules&amp;#34;: true, &amp;#34;[typescriptreact]&amp;#34;: { &amp;#34;editor.defaultFormatter&amp;#34;: &amp;#34;esbenp.prettier-vscode&amp;#34; }, &amp;#34;[typescript]&amp;#34;: { &amp;#34;editor.defaultFormatter&amp;#34;: &amp;#34;esbenp.prettier-vscode&amp;#34; } } NPM 安装 prettier lint-staged pre-commit
以下是 package.json 配置：
{ &amp;#34;pre-commit&amp;#34;: [ &amp;#34;lint-staged&amp;#34; ], &amp;#34;lint-staged&amp;#34;: { &amp;#34;*.{js,jsx,less,md,json}&amp;#34;: [ &amp;#34;prettier --write&amp;#34; ], &amp;#34;*.ts?(x)&amp;#34;: [ &amp;#34;prettier --parser=typescript --write&amp;#34; ] }, } 参考  https://github.com/prettier/prettier-vscode#prettier-resolution https://prettier.io/docs/en/configuration.html  </description>
    </item>
    
    <item>
      <title>umi.define 应用问题</title>
      <link>https://sengmitnick.com/blog/331/</link>
      <pubDate>Mon, 10 May 2021 14:52:35 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/331/</guid>
      <description>这是工作中看到同事的错误写法，特意记录下来～
  错误写法
   相关使用文档：https://umijs.org/zh-CN/config#define
 原理分析
   原理分析： define 中的变量在生产环境会被压缩掉，如果通过 const {PXX_ENV1, PLATFORM1} = process.env; 方式取值，会先被编译成以上截图代码，导致在生产环境中并没有被压缩掉～</description>
    </item>
    
    <item>
      <title>利用 gitee pages 提速自己的个人网站</title>
      <link>https://sengmitnick.com/blog/317/</link>
      <pubDate>Sun, 25 Apr 2021 16:35:30 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/317/</guid>
      <description>前言 前阵子我在服务器上搭建的 v2Ray 挂了，无奈之下启动B计划，搭建了 Trojan 服务器，但是搭建成功后，虽然可以继续愉快的科学上网，却导致之前基于 Nginx 搭建的站点都挂掉了。不过还好，我的Nginx上面只配置了两个站点，一个就是目前的博客，还有就是我的 Cloud IED 了。
Cloud IED 可以通过修改 Trojan 服务器-伪装站点的 root 位置继续使用。而本来的博客站点，则可以考虑通过 GiteePages + dcnd 进行解决。
开启 Gitee Pages 服务 之前我的源码是放在GitHub上面，通过 Gitee 的导入仓库功能就可以导入我的源码到其上了。然后就是通过 gh-pages 进行作业啦～
could not find image 就是每次更新站点有点繁琐，需要先同步GitHub，然后到 Gitee Pages 的页面进行更新。
通过阿里的 DCDN 进行全球加速 如果使用的是 GitHub Pages 功能的话，通过其中的自定义域名即可把自己的域名绑定并且可以自动更新HTTPS证书了。但是 Gitee Pages 并没有开放该功能（之前貌似有的，不过好像因为国内政策问题就关掉了），而我的站点评论使用的是 disqus，如果直接用 Gitee 提供的域名的花，评论数据就比较麻烦了。
所以我在想是否可以通过CDN的方式来曲线实现原有的自定义功能呢？一开始我是使用七牛的CDN进行的，因为一开始我就打算通过七牛的 Kodo + CDN 进行网站的迁移+提升，但是发现Kodo的站点功能有点缺陷，最后才选择了 Gitee Pages 。后面单纯的使用七牛的CDN也不行，一直卡在测试不通过。最后通过了阿里云的全站加速DCDN实现了，至于后面有什么坑再说啦～
&amp;mdash;END</description>
    </item>
    
  </channel>
</rss>
