<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>technology on Seng Mitnick</title>
    <link>https://sengmitnick.com/categories/technology/</link>
    <description>Recent content in technology on Seng Mitnick</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 21 Mar 2021 13:55:43 +0000</lastBuildDate><atom:link href="https://sengmitnick.com/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于disqus-php-api在Hexo博客中使用Disqus</title>
      <link>https://sengmitnick.com/blog/104/</link>
      <pubDate>Sun, 16 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://sengmitnick.com/blog/104/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;废话少说，这里基于 &lt;a href=&#34;https://fooleap.org&#34;&gt;fooleap&lt;/a&gt; 的 &lt;a href=&#34;https://github.com/fooleap/disqus-php-api&#34;&gt;disqus-php-api&lt;/a&gt; 对Hexo中的NexT主题进行兼容。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>什么时候使用 useMemo 和 useCallback</title>
      <link>https://sengmitnick.com/blog/320/</link>
      <pubDate>Sun, 21 Mar 2021 13:55:43 +0000</pubDate>
      
      <guid>https://sengmitnick.com/blog/320/</guid>
      <description> 前阵子，在帮同事查看一个 Bug 时，发现用的一个组件里面，在调用事件里面使用值一直不生效，最后发现是 改组件渲染部分用了 useMemo 所致。
 演示  参考  【译】什么时候使用 useMemo 和 useCallback When to useMemo and useCallback  </description>
    </item>
    
    <item>
      <title>WSL 使用指北</title>
      <link>https://sengmitnick.com/blog/313/</link>
      <pubDate>Thu, 11 Mar 2021 11:26:49 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/313/</guid>
      <description>什么是 WSL  WSL - Windows Subsystem for Linux The Windows Subsystem for Linux lets developers run Linux environments &amp;ndash; including most command-line tools, utilities, and applications &amp;ndash; directly on Windows, unmodified, without the overhead of a virtual machine.
 Linux 的 Windows 子系统让开发人员无需虚拟机就可以直接在 Windows 上运行 Linux 环境，包括大多数命令行工具、程序和应用。
使用 WSL 的好处是：
与在虚拟机下使用 Linux 相比，WSL 更加流畅； WSL 可以对 Windows 文件系统下的文件直接进行读写，文件传输更方便； 剪贴板互通，可以直接在 Windows 下其它地方复制文本内容，粘贴到 WSL；
开启 WSL 在 控制面板&amp;ndash;&amp;gt;程序和功能 页面找到 Windows 功能 ，在 Windows 功能 窗口中勾选 适用于 Linux 的 Windows 子系统 功能，点击确定，并按照提示重启电脑。</description>
    </item>
    
    <item>
      <title>dependencies和devDependencies的区别</title>
      <link>https://sengmitnick.com/blog/312/</link>
      <pubDate>Wed, 10 Mar 2021 16:28:36 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/312/</guid>
      <description>当我们项目需要下载一个模块的时候，我们安装npm包（在项目目录下面npm install module_name）的时候，很多时候我们会在后面加上–save-dev 或 –save。这两个参数代表什么呢？
初识 相信很多人都会回答：
npm install module-name -save 自动把模块和版本号添加到dependencies部分 npm install module-name -save-dev 自动把模块和版本号添加到devdependencies部分
dependencies是什么呢？ 生产环境。 devdependencies是什么呢？ 开发环境。 网上也可以查到很多资料，大概回答意思是，我们搭建一个webpack+react+es6的项目，像webpack babel这种负责打包编译的，我们就应该装在开发环境，像react之类的装在生产环境。 可是为什么呢？ 我们不能告诉我们这样做，我们就只这样做，我们要知之其所以然呀。 恩。我试着吧react放进了dependencies，打包出来的文件依然可以运行，并没有什么问题。 why ？？？难道文档只是建议而已吗？？？
实质区别 如果我们只是单纯的做项目，那么我们可简单地认为生产环境和开发环境做为一种友善的提示，实质没有什么区别；但是，如果在发布npm包的时候，两种环境安装方式是有很大区别的！！！
假设有以下两个模块： 模块A
 devDependencies 模块B dependencies 模块C 模块D devDependencies 模块E dependencies 模块A npm install D的时候， 下载的模块为： D A C 当我们下载了模块D的源码，并且在根目录下npm install， 下载的模块为： A C E 所以，在发布npm包的时候，本身dependencies下的模块会作为依赖，一起被下载；devDependencies下面的模块就不会自动下载了；但对于项目而言，npm install 会自动下载devDependencies和dependencies下面的模块。  参考  specifying-dependencies-and-devdependencies-in-a-package-json-file 包应该放在devDependencies还是dependencies  </description>
    </item>
    
    <item>
      <title>打造专属自己的CloudIDE</title>
      <link>https://sengmitnick.com/blog/308/</link>
      <pubDate>Mon, 22 Feb 2021 21:09:48 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/308/</guid>
      <description>前言 最近带着小白到处玩，发现小白太重了，究其原因，是因为小白的本重+充电器。遂想能否有一台较轻并且续航久的笔记本用来外出使用呢？一开始想通过iPad+code-server发现效果不是很完美，于是再三选择用google pixel slate+code-server。于是就有了这篇文章。
安装 安装code-server curl -fsSL https://code-server.dev/install.sh | sh -s -- --dry-run nginx 反向代理 使用公网ip访问，非常不优雅，而且无法正常使用 https。因此需要使用反向代理的方式，通过指定的域名，让反向代理服务器将对应的请求Request发送到本地对应的端口上去，这样就实现了可以直接使用域名来访问，不必再加上端口号。
upstream wss_code { server 127.0.0.1:内网穿透/code-server的端口 weight=1; } server { listen 80; server_name 域名; server_tokens off; return 301 https://$server_name$request_uri; } server { listen 443 ssl; ssl_certificate 公钥路径; # path to your cacert.pem ssl_certificate_key 私钥路径; # path to your privkey.pem server_name 域名; #配置共享会话缓存大小 ssl_session_cache shared:SSL:10m; #配置会话超时时间 ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers &amp;#39;ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-CAMELLIA256-SHA:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-SEED-SHA:DHE-RSA-CAMELLIA128-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS&amp;#39;; server_tokens off; location / { proxy_pass http://wss_code; # 转发 proxy_read_timeout 1200s; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr:$remote_port; proxy_http_version 1.</description>
    </item>
    
    <item>
      <title>Ubuntu下安装zsh和oh-my-zsh</title>
      <link>https://sengmitnick.com/blog/305/</link>
      <pubDate>Tue, 16 Feb 2021 12:03:26 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/305/</guid>
      <description>前言 网上教程一堆，为什么我还要写一篇？ 其实按照步骤及其简单，就两句命令行。但是，我之前在新的MacOS安装，并配置了一些插件，以达到我之前的小白下的模式，发现总感觉差了点。逐有了这一篇教程，主要还是备份下在新的系统下安装了什么插件～
安装 官方安装文档教程：
 Installing ZSH Install oh-my-zsh now  我在Ubuntu下执行以下命令：
apt install zsh sh -c &amp;#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;#34; 安装并配置ohmyz插件 安装zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 配置文件.zshrc如下：
# If you come from bash you might have to change your $PATH. export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH=&amp;#34;/root/.oh-my-zsh&amp;#34; # Set name of the theme to load --- if set to &amp;#34;random&amp;#34;, it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.</description>
    </item>
    
    <item>
      <title>Hugo下添加 Back Top 功能</title>
      <link>https://sengmitnick.com/blog/304/</link>
      <pubDate>Wed, 10 Feb 2021 12:28:23 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/304/</guid>
      <description> 在给文章设置了Hugo默认的TOC功能后，发现如果文章过长，每次返回顶部抵达段落的过程太麻烦，虽然在我的Google Pixel Slate下通过gg即可快速回到顶部，但是我还是觉得有必要给我站点添加 Back Top 的功能
 在动手之前，也可考虑其必要性，在这里大家有过一定程度的讨论，也是看了这里我才知道还可以通过gg可快速回到顶部:)
目前功能实现的代码可直接参考：9e6ba0c
虽然还不是很完美，但也可基本使用了。后续慢慢迭代吧:)
参考资料  添加一键返回顶部功能 5种回到顶部的写法从实现到增强  </description>
    </item>
    
    <item>
      <title>根据 swagger 文档生成 typescript 客户端调用代码</title>
      <link>https://sengmitnick.com/blog/306/</link>
      <pubDate>Wed, 16 Dec 2020 15:59:47 +0800</pubDate>
      
      <guid>https://sengmitnick.com/blog/306/</guid>
      <description>新公司后端API文档基于swagger打造，于是在项目开发过程中萌生了通过nodejs生成typescript接口函数的想法。
 在GitHub、npm和gitee找了一下，发现nswag-ts基本满足需求。
安装 yarn add -D nswagger-ts 在 package.json 的 scripts 节点增加 2 个执行命令
{ &amp;#34;scripts&amp;#34;: { &amp;#34;nswag:init&amp;#34;: &amp;#34;nswag init&amp;#34;, &amp;#34;nswag:run&amp;#34;: &amp;#34;nswag run&amp;#34;, } }  执行：yarn nswag-init 初始化项目 初始化完成后会在项目根目录创建文件夹 nswag,里面放置了配置文件及代码模板  以下是我的配置文件,支持多个模块生成。
var _ = require(&amp;#39;lodash&amp;#39;); const SwaggerUrlBase = &amp;#39;https://demo.com/api/%s/v2/api-docs&amp;#39;; const Apis = [&amp;#39;contents&amp;#39;, &amp;#39;material&amp;#39;, &amp;#39;customer&amp;#39;, &amp;#39;community&amp;#39;, &amp;#39;push&amp;#39;, &amp;#39;user&amp;#39;, &amp;#39;platform&amp;#39;] .map(tagName =&amp;gt; { return { SwaggerUrl: SwaggerUrlBase.replace(&amp;#39;%s&amp;#39;, tagName), ApiName: tagName.charAt(0).toUpperCase() + tagName.slice(1), }; }) .map(({ SwaggerUrl, ApiName }) =&amp;gt; ({ SwaggerUrl, // 接口文档地址（必填）  ApiBase: &amp;#39;/api&amp;#39;, // 接口根节点（必填）  ApiName, // 接口名称（必填）  // // OutPath: &amp;#39;&amp;#39;, // 输出目录（默认：项目根/src/api/{ApiName}）  // // TplPath: &amp;#39;&amp;#39;, // 模板路径（默认：内部默认模板，也可以copy 到项目中进行修改，然后指定用项目中模板）  // // Mock: false, // 是否启用模拟数据 （默认：false）  // // FormatMock: null, // 接管模拟数据格式化  FormatControllerName: function(name) { // 格式化模块名称（默认：接口名称+Api）  return name .</description>
    </item>
    
    <item>
      <title>微信小程序--通过leancloud做后台发送模板消息</title>
      <link>https://sengmitnick.com/blog/101/</link>
      <pubDate>Sun, 02 Jul 2017 16:18:15 +0000</pubDate>
      
      <guid>https://sengmitnick.com/blog/101/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;利用通过leancloud做后台，接受微信小程序发送过来的form_id，接受并处理后向微信模板信息API发送让用户获取对应模板消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，所有操作根据官方文档&lt;a href=&#34;https://mp.weixin.qq.com/debug/wxadoc/dev/api/notice.html&#34;&gt;https://mp.weixin.qq.com/debug/wxadoc/dev/api/notice.html&lt;/a&gt;进行，本文章只介绍如何使用leancloud获取 &lt;code&gt;access_token&lt;/code&gt; 和通过LeanEngine发送模板消息，而如何创建模板及获取模板id请查看官方文档，这里不进行详述。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>通过leancloud创建hexo博客并具备后台管理功能</title>
      <link>https://sengmitnick.com/blog/102/</link>
      <pubDate>Sun, 02 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://sengmitnick.com/blog/102/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;leancloud的云引擎 &lt;code&gt;LeanEngine&lt;/code&gt; 可以部署网站，那么通过LeanEngine当然也可以部署hexo了，况且有hexo-admin插件，可以在部署完成后通过后台进行管理，完全适合不会使用命令行的人使用了~&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
